<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>簡單射擊遊戲1.2</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #111;
        }
        canvas {
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <script>
		const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const WIDTH = canvas.width = window.innerWidth;
        const HEIGHT = canvas.height = window.innerHeight;

        // 遊戲元素
        let player = { x: WIDTH / 2, y: HEIGHT - 70, width: 50, height: 50, speed: 5 };
        let bullets = [];
        let enemies = [];
        let score = 0;
        let gameOver = false;
        let enemyGenerationInterval = 0;
        let explosionParticles = [];
		let lastEnemySpawnTime = 0;// 記錄上一次敵人生成的時間（毫秒）

        // 控制玩家移動
        let moveLeft = false, moveRight = false;
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') moveLeft = true;
            if (e.key === 'ArrowRight') moveRight = true;
            if (e.key === ' ') shootBullet(); // 空白鍵發射子彈
        });
        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft') moveLeft = false;
            if (e.key === 'ArrowRight') moveRight = false;
        });

        // 玩家飛機
		function drawPlayer() {
		const gradient = ctx.createLinearGradient(player.x, player.y, player.x + player.width, player.y + player.height);
		gradient.addColorStop(0, '#4CAF50');
		gradient.addColorStop(1, '#388E3C');
		ctx.fillStyle = gradient;

		// 繪製機身
		ctx.beginPath();
		ctx.moveTo(player.x + 25, player.y); // 頂點
		ctx.lineTo(player.x, player.y + 50); // 左底
		ctx.lineTo(player.x + 50, player.y + 50); // 右底
		ctx.closePath();
		ctx.fill();

		// 繪製左機翼
		ctx.beginPath();
		ctx.moveTo(player.x + 10, player.y + 20);
		ctx.lineTo(player.x, player.y + 40);
		ctx.lineTo(player.x + 20, player.y + 40);
		ctx.closePath();
		ctx.fill();

		// 繪製右機翼
		ctx.beginPath();
		ctx.moveTo(player.x + 40, player.y + 20);
		ctx.lineTo(player.x + 50, player.y + 40);
		ctx.lineTo(player.x + 30, player.y + 40);
		ctx.closePath();
		ctx.fill();

		// 繪製尾翼
		ctx.beginPath();
		ctx.moveTo(player.x + 25, player.y + 50);
		ctx.lineTo(player.x + 20, player.y + 60);
		ctx.lineTo(player.x + 30, player.y + 60);
		ctx.closePath();
		ctx.fill();
	}

        // 子彈
        function shootBullet() {
            if (gameOver) return;
            bullets.push({ x: player.x + player.width / 2 - 5, y: player.y, width: 10, height: 20, speed: 6.5 });
        }

        // 繪製子彈
		function drawBullets() {
			bullets = bullets.filter(bullet => {
				bullet.y -= bullet.speed;
				if (bullet.y < 0) return false;

				// 子彈主體
				ctx.fillStyle = 'yellow';
				ctx.beginPath();
				ctx.rect(bullet.x, bullet.y, bullet.width, bullet.height * 2); // 細長矩形
				ctx.fill();

				// 尾跡效果
				const gradient = ctx.createLinearGradient(bullet.x, bullet.y, bullet.x, bullet.y + 20);
				gradient.addColorStop(0, 'rgba(255, 255, 0, 0.8)');
				gradient.addColorStop(1, 'rgba(255, 255, 0, 0)');
				ctx.fillStyle = gradient;
				ctx.fillRect(bullet.x, bullet.y + bullet.height, bullet.width, 20);

				return true;
			});
		}

        // 創建敵人
		let ENEMY_SPAWN_INTERVAL = 2000 - Math.floor(score / 100) * 50;
		if (ENEMY_SPAWN_INTERVAL < 500) ENEMY_SPAWN_INTERVAL = 500;

		function spawnEnemy() {
		  const currentTime = Date.now();
		  if (currentTime - lastEnemySpawnTime > ENEMY_SPAWN_INTERVAL) {
			const enemy = createEnemy(Math.floor(Math.random() * 3));
			enemies.push(enemy);
			lastEnemySpawnTime = currentTime;
		  }
		}

        // 創建不同類型的敵人
		function createEnemy(type) {
		  const speedMultiplier = 1 + Math.floor(score / 200) * 0.5;
		  const baseEnemy = { x: Math.random() * (WIDTH - 50), y: -50, width: 50, height: 50, bullets: [] };
		  switch (type) {
			case 0: return { ...baseEnemy, speed: 2.5 * speedMultiplier, type: 'normal' };
			case 1: return { ...baseEnemy, speed: 4.5 * speedMultiplier, type: 'fast' };
			case 2: return { ...baseEnemy, speed: 3.0 * speedMultiplier, type: 'shooter', shooting: true, lastShot: 0 };
			default: return { ...baseEnemy, speed: 2.5 * speedMultiplier, type: 'normal' };
		  }
		}
		//生成爆炸
		const MAX_PARTICLES = 200;

		function spawnExplosion(x, y) {
			if (explosionParticles.length < MAX_PARTICLES) {
				for (let i = 0; i < 10; i++) {
					explosionParticles.push({
						x, y,
						life: 30,
						size: Math.random() * 5 + 2,
						dx: Math.random() * 4 - 2,
						dy: Math.random() * 4 - 2,
						color: Math.random() > 0.5 ? 'orange' : 'red'
					});
				}
			}
		}
		//繪製爆炸
		function drawExplosions() {
			explosionParticles = explosionParticles.filter(explosion => {
				ctx.beginPath();
				ctx.arc(explosion.x, explosion.y, explosion.size, 0, Math.PI * 2);
				const gradient = ctx.createRadialGradient(explosion.x, explosion.y, 0, explosion.x, explosion.y, explosion.size);
				gradient.addColorStop(0, explosion.color);
				gradient.addColorStop(1, 'transparent');
				ctx.fillStyle = gradient;
				ctx.fill();

				explosion.x += explosion.dx;
				explosion.y += explosion.dy;
				explosion.size += 0.2;
				explosion.life--;
				return explosion.life > 0;
			});
		}

        // 敵人
		function drawEnemies() {
			for (let index = enemies.length - 1; index >= 0; index--) {
				const enemy = enemies[index];
				enemy.y += enemy.speed;
				if (enemy.y > HEIGHT) gameOver = true;

				enemy.y += Math.sin(Date.now() * 0.005 + index) * 0.3;

				ctx.fillStyle = enemy.type === 'normal' ? 'red' : enemy.type === 'fast' ? 'yellow' : 'blue';
				ctx.beginPath();
				if (enemy.type === 'normal') {
					ctx.rect(enemy.x, enemy.y, enemy.width, enemy.height);
				} else if (enemy.type === 'fast') {
					ctx.moveTo(enemy.x + 25, enemy.y);
					ctx.lineTo(enemy.x, enemy.y + 50);
					ctx.lineTo(enemy.x + 50, enemy.y + 50);
					ctx.closePath();
				} else if (enemy.type === 'shooter') {
					ctx.rect(enemy.x, enemy.y, enemy.width, enemy.height);
					ctx.rect(enemy.x + 20, enemy.y + enemy.height, 10, 10);
				}
				ctx.fill();

				if (enemy.type === 'shooter' && Math.random() < 0.015 && enemy.lastShot <= 0) {
				  shootEnemyBullet(enemy);
				  enemy.lastShot = 60;
				}
				if (enemy.lastShot > 0) enemy.lastShot--;

				for (let bIndex = bullets.length - 1; bIndex >= 0; bIndex--) {
					const bullet = bullets[bIndex];
					if (bullet.x < enemy.x + enemy.width && bullet.x + bullet.width > enemy.x &&
						bullet.y < enemy.y + enemy.height && bullet.y + bullet.height > enemy.y) {
					  let points = enemy.type === 'normal' ? 10 : enemy.type === 'fast' ? 15 : 20;
					  score += points;
					  enemies.splice(index, 1);
					  bullets.splice(bIndex, 1);
					  spawnExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
					  break;
					}
				}

				enemy.bullets.forEach((bullet, bIndex) => {
					if (bullet.x < player.x + player.width && bullet.x + bullet.width > player.x &&
						bullet.y < player.y + player.height && bullet.y + bullet.height > player.y) {
						gameOver = true;
					}
					bullet.y += bullet.speed;
					if (bullet.y > HEIGHT) enemy.bullets.splice(bIndex, 1);
					ctx.fillStyle = 'red';
					ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
				});
			}
		}
			for (let index = enemies.length - 1; index >= 0; index--) {
				const enemy = enemies[index];
				enemy.y += enemy.speed;
				if (enemy.y > HEIGHT) gameOver = true;

				enemy.y += Math.sin(Date.now() * 0.005 + index) * 0.5;

				ctx.fillStyle = enemy.type === 'normal' ? 'red' : enemy.type === 'fast' ? 'yellow' : 'blue';
				ctx.beginPath();
				if (enemy.type === 'normal') {
					ctx.rect(enemy.x, enemy.y, enemy.width, enemy.height);
				} else if (enemy.type === 'fast') {
					ctx.moveTo(enemy.x + 25, enemy.y);
					ctx.lineTo(enemy.x, enemy.y + 50);
					ctx.lineTo(enemy.x + 50, enemy.y + 50);
					ctx.closePath();
				} else if (enemy.type === 'shooter') {
					ctx.rect(enemy.x, enemy.y, enemy.width, enemy.height);
					ctx.rect(enemy.x + 20, enemy.y + enemy.height, 10, 10);
				}
				ctx.fill();

				if (enemy.type === 'shooter' && Math.random() < 0.02 && enemy.lastShot <= 0) {
					shootEnemyBullet(enemy);
					enemy.lastShot = 60;
				}
				if (enemy.lastShot > 0) enemy.lastShot--;

				for (let bIndex = bullets.length - 1; bIndex >= 0; bIndex--) {
					const bullet = bullets[bIndex];
					if (bullet.x < enemy.x + enemy.width && bullet.x + bullet.width > enemy.x &&
						bullet.y < enemy.y + enemy.height && bullet.y + bullet.height > enemy.y) {
						enemies.splice(index, 1);
						bullets.splice(bIndex, 1);
						score += 10;
						spawnExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
						break;
					}
				}

				enemy.bullets.forEach((bullet, bIndex) => {
					if (bullet.x < player.x + player.width && bullet.x + bullet.width > player.x &&
						bullet.y < player.y + player.height && bullet.y + bullet.height > player.y) {
						gameOver = true;
					}
					bullet.y += bullet.speed;
					if (bullet.y > HEIGHT) enemy.bullets.splice(bIndex, 1);
					ctx.fillStyle = 'red';
					ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
				});
			}




		

        // 快速敵人發射子彈
        function shootEnemyBullet(enemy) {
            enemy.bullets.push({ x: enemy.x + enemy.width / 2 - 5, y: enemy.y + enemy.height, width: 10, height: 20, speed: 4.5 });
        }

        // 顯示分數
		function drawScore() {
			ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
			ctx.fillRect(10, 10, 150, 40);
			ctx.strokeStyle = 'white';
			ctx.strokeRect(10, 10, 150, 40);
			ctx.font = '20px Arial';
			ctx.fillStyle = 'white';
			ctx.fillText(`分數: ${score}`, 20, 35);
		}

        // 遊戲結束顯示
		function drawGameOver() {
			ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
			ctx.fillRect(WIDTH / 2 - 150, HEIGHT / 2 - 100, 300, 200);
			ctx.strokeStyle = 'white';
			ctx.strokeRect(WIDTH / 2 - 150, HEIGHT / 2 - 100, 300, 200);

			ctx.fillStyle = 'white';
			ctx.font = '40px Arial';
			ctx.fillText('遊戲結束!', WIDTH / 2 - 100, HEIGHT / 2 - 30);
			ctx.font = '30px Arial';
			ctx.fillText(`最終分數: ${score}`, WIDTH / 2 - 90, HEIGHT / 2 + 20);

			ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
			ctx.fillRect(WIDTH / 2 - 50, HEIGHT / 2 + 50, 100, 40);
			ctx.fillStyle = 'white';
			ctx.font = '20px Arial';
			ctx.fillText('重玩', WIDTH / 2 - 25, HEIGHT / 2 + 75);

			canvas.addEventListener('click', (e) => {
				const rect = canvas.getBoundingClientRect();
				const clickX = e.clientX - rect.left;
				const clickY = e.clientY - rect.top;
				if (clickX > WIDTH / 2 - 50 && clickX < WIDTH / 2 + 50 &&
					clickY > HEIGHT / 2 + 50 && clickY < HEIGHT / 2 + 90) {
					location.reload();
				}
			}, { once: true });
		}

        // 背景
		let stars = [];
        for (let i = 0; i < 100; i++) {
            stars.push({
                x: Math.random() * WIDTH,
                y: Math.random() * HEIGHT,
                size: Math.random() * 2
            });
        }

		function drawBackground() {
            const gradient = ctx.createLinearGradient(0, 0, 0, HEIGHT);
            gradient.addColorStop(0, '#1e3c72');
            gradient.addColorStop(1, '#2a5298');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            ctx.fillStyle = 'white';
            stars.forEach(star => {
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // 更新遊戲畫面
		function updateGame() {
			console.log('遊戲循環運行中...'); // 調試用
			if (gameOver) {
				drawGameOver();
				return;
			}

			ctx.clearRect(0, 0, WIDTH, HEIGHT);

			if (moveLeft && player.x > 0) player.x -= player.speed;
			if (moveRight && player.x + player.width < WIDTH) player.x += player.speed;

			drawBackground();
			drawPlayer();
			drawBullets();
			drawEnemies();
			drawExplosions();
			drawScore();
			spawnEnemy();

			if (enemyGenerationInterval > 0) enemyGenerationInterval--;

			requestAnimationFrame(updateGame);
		}
        // 開始遊戲
        updateGame();
    </script>
</body>
</html>
